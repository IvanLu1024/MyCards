# 一、架构

## 1.1 如何设计一个关系型数据库

从以下模块展开论述：

- 存储（文件系统）：机械硬盘/SSD固态硬盘
- 程序实例
  - 存储管理：为了减少磁盘I/O的次数，一次读取多行数据，通常是读入一个数据块或页；
  - 缓存机制：LRU等
  - SQL解析：将部分SQL结果缓存
  - 日志管理：主从同步、灾难恢复
  - 权限划分：支持多用户
  - 容灾机制
  - **索引管理**：优化数据查询效率
  - **锁管理**：支持并发操作

# 二、索引模块

## 2.1 为什么要使用索引

为了避免全表检索的低效，借鉴目录的思想，快速检索。



## 2.2 什么样的信息能成为索引

- 主键、唯一键以及普通键等



## 2.3 索引的数据结构

为了使得查询高效：

- 生成索引，建立二叉查找树进行二分查找
- 生成索引，建立B树进行查找
- **生成索引，建立B+树进行查找**
- 生成索引，建立Hash结构进行查找

B+树更适合用来用存储索引

- B+树的磁盘读写代价更低，因为非叶子结点只存储索引，其内部存储空间更小，这样一次性读入内存的数据就更多，相对来说磁盘的I/O次数就减少了。
- B+树的查询效率更加稳定，由于每一条查询都是从根结点到叶子结点，所有关键字的查询路径相同。
- B+树更有利于对数据库的扫描，由于B+树的叶子结点由链表连接，这样使得一次查询就能够读取到一定范围的数据，更加有利于数据库的范围查询。

Hash索引的缺点

- 仅仅能够满足“=”，“IN”，不能使用范围查询；
- 索引无法用来数据的排序操作；
- 不能利用部分索引键查询，即组合索引；
- 不能避免表扫描；
- 遇到大量Hash冲突的情况效率会大大降低

## 2.4 密集索引和稀疏索引的区别

密集索引

叶子结点保存的不仅仅是键值，还保存了位于同一行记录中其他列的信息。由于密集索引决定了表的物理排列顺序，一个表只能有一个物理排列顺序，所以一个表只能创建一个密集索引。

- 文件中的每个搜索码值都对应一个索引值

稀疏索引

叶子结点仅仅保存了键位信息以及该行的地址，有的稀疏索引是仅仅保存了键位信息及其主键。定位到叶子结点后，仍然需要地址或主键进一步定位信息。

- 只为索引码的某些值建立索引项

MyISAM：

所有索引都是稀疏索引,其中索引和数据是分开存储的。

InnoDB：

行数据和主键索引是保存在同一个文件中的，有且仅有一个密集索引，这个密集索引的选取规则：

- 若一个主键被定义，该主键则作为密集索引；
- 若没有主键被定义，该表的第一个唯一非空索引则作为密集索引；
- 若不满足以上条件，InnoDB内部会生成一个隐藏主键（密集索引），这个隐藏主键是一个6字节的列，会随着数据的插入而递增；
- 非主键索引，就是稀疏索引的叶子结点并不存储行数据的物理地址，而是存储相关键位和其对应的主键值，包含两次查找，一次是查找次级索引自身，再查找主键

<div align="center">
    <img src="https://gitee.com/IvanLu1024/picts/raw/119abfbd00c0dad4151fc70a39eb088731ddabe1/blog/database/10154499-5772dddedb909374.png"/>
</div>



> 补充资料：<https://www.jianshu.com/p/fa8192853184>

衍生出来的问题，以MySQL为例

## 2.5 如何定位并优化慢查询SQL

具体场景具体分析，只提出大致思路：

- **根据慢日志定位慢查询SQL**

<div align="center">
    <img src="https://gitee.com/IvanLu1024/picts/raw/master/blog/database/20190521202152.png"/>
</div>

- **使用EXPLAIN等工具分析SQL语句**

<div align="center">
    <img src="https://gitee.com/IvanLu1024/picts/raw/master/blog/database/20190521204647.png"/>
</div>

EXPLAIN关键字段

1. type

<div align="center">
    <img src="https://gitee.com/IvanLu1024/picts/raw/master/blog/database/20190521205321.png"/>
</div>

性能由高到低，index和all表示本次查询是全表扫描。

2. extra

extra中出现以下两项意味着MySQL根本不能使用索引，效率会受到重大影响。应尽可能对此进行优化：

| extra项         | 说明                                                         |
| --------------- | ------------------------------------------------------------ |
| Using filesort  | 表示MySQL会对结果使用一个外部索引排序，而不是从表里按索引次序读到相关内容，可能在内存或磁盘上进行排序。MySQL中无法利用索引完成的排序操作成为“文件排序”。 |
| Using temporary | 表示MySQL在对查询结果排序时使用临时表。常见于排序order by和分组查询group by。 |

- **修改SQL或尽量让SQL走索引**

## 2.6 联合索引的最左匹配原则的成因

1. 最左前缀匹配原则，MySQL会一直向右匹配直到遇到范围查询（> 、<、between、like）就停止匹配；
2. =和in可以乱序，因为MySQL的查询优化器可以帮助优化成索引可以识别的形式；

MySQL在创建复合索引的规则是，首先对第一个的索引字段进行排序，在此基础上再对第二个索引字段进行排序，实现了类似于order by 字段1 再order by 字段2。所以第一个字段是绝对有序的，而第二个字段就是无序的。因此直接使用第二个字段进行条件查询就无法使用复合索引。



## 2.7 索引是建立得越多越好吗

- 数据量小的表不需要建立索引，建立会增加额外的索引开销；
- 数据变更需要维护索引，因此更多的索引意味着更多的维护成本；
- 更多的索引意味着也需要更多的空间；

